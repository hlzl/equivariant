from __future__ import annotations

from .utils import build_adjoint_map
from .group import Group, GroupElement
from .cyclicgroup import CyclicGroup
from .dihedralgroup import DihedralGroup
from .so2group import SO2

from equivariant import group_theory
from equivariant.group_theory.utils import psichi, cycle_isclose

import numpy as np
from functools import partial

from typing import Tuple, Callable, Iterable, List, Union


__all__ = ["O2"]


class O2(Group):
    def __init__(self, maximum_frequency: int = 6):
        r"""
        Build an instance of the orthogonal group :math:`O(2)` which contains reflections and continuous planar
        rotations.

        Any group element is either a rotation :math:`r_{\theta}` by an angle :math:`\theta \in [0, 2\pi)` or a
        reflection :math:`f` followed by a rotation, i.e. :math:`r_{\theta}f`.
        Two reflections gives the identity :math:`f \cdot f = e` and a reflection commutes with a rotation by
        inverting it, i.e. :math:`r_\theta \cdot f = f \cdot r_{-\theta}`.
        A group element :math:`r_{\theta}f^j` is implemented as a pair :math:`(j, \theta)` with :math:`j \in \{0, 1\}`
        and :math:`\theta \in [0, 2\pi)`.

        .. note ::

            Since the group has infinitely many irreducible representations, it is not possible to build all of them.
            Each irrep is associated to one unique integer frequency and the parameter ``maximum_frequency`` specifies
            the maximum frequency of the irreps to build.
            New irreps (associated to higher frequencies) can be manually created by calling the method
            :meth:`~O2.irrep` (see the method's documentation).


        Subgroup Structure.

        A subgroup of :math:`O(2)` is identified by a tuple ``id`` :math:`(\theta, M)`.

        Here, :math:`M` can be either a positive integer indicating the number of rotations in the subgroup or
        :math:`-1`, indicating that the subgroup contains all continuous rotations.
        :math:`\theta` is either ``None`` or an angle in :math:`[0, \frac{2\pi}{M})`.
        If :math:`\theta` is ``None``, the subgroup does not contain any reflections.
        Otherwise, the subgroup contains the reflection :math:`r_{\theta}f` along the axis of the current group rotated
        by :math:`\frac{\theta}{2}`.

        Valid combinations are:
        - (``None``, :math:`M>0`): restrict to the cyclic subgroup :math:`C_M` generated by :math:`\langle r_{2\pi/M} \rangle`.
        - (``None``, :math:`-1`): restrict to the subgroup :math:`SO(2)` containing only the rotations
        - (:math:`\theta`, :math:`M>0`): restrict to the dihedral subgroup :math:`D_{M}` generated by :math:`\langle r_{2\pi/M}, r_{\theta} f \rangle`

        In particular:
        - (:math:`0`, :math:`1`): restrict to the reflection group generated by :math:`\langle f \rangle`
        - (:math:`0`, :math:`M`): restrict to the dihedral subgroup :math:`D_{M}` generated by :math:`\langle r_{2\pi/M}, f \rangle`
        - (``None``, :math:`1`): restrict to the cyclic subgroup of order 1 containing only the identity

        Args:
            maximum_frequency (int, optional): the maximum frequency to consider when building the irreps of the group

        Attributes:

            ~.reflection: the reflection element :math:`(j, \theta) = (1, 0.)`

        """

        assert isinstance(maximum_frequency, int) and maximum_frequency >= 0

        super(O2, self).__init__("O(2)", True, False)

        self.rotation_order = -1
        self._maximum_frequency = maximum_frequency
        self._identity = self.element((0, 0.0))
        self.reflection = self.element((1, 0.0))

        self._build_representations()

    @property
    def generators(self) -> List[GroupElement]:
        raise ValueError(
            f"{self.name} is a continuous groups and "
            f"some of its generators are infinitesimal. "
            f"This is not currently supported"
        )

    @property
    def subgroup_trivial_id(self):
        return (None, 1)

    @property
    def subgroup_self_id(self):
        return (0.0, -1)

    ###########################################################################
    # METHODS DEFINING THE GROUP LAW AND THE OPERATIONS ON THE GROUP'S ELEMENTS
    ###########################################################################

    def sample(self) -> GroupElement:
        return self.element((np.random.randint(0, 2), np.random.random() * 2 * np.pi))

    def grid(
        self, N: int, type: str = "regular", seed: int = None
    ) -> List[GroupElement]:
        r"""
        .. todo::
            Add documentation

        """

        if type == "regular":
            grid = [(0, i * 2 * np.pi / N) for i in range(N)] + [
                (1, i * 2 * np.pi / N) for i in range(N)
            ]
        elif type == "rand":
            if isinstance(seed, int):
                rng = np.random.RandomState(seed)
            elif seed is None:
                rng = np.random
            else:
                assert isinstance(seed, np.random.RandomState)
                rng = seed
            grid = [(rng.randint(0, 2), rng.random() * 2 * np.pi) for i in range(N)]
        else:
            raise ValueError(f"Grid type {type} not recognized")

        return [self.element(g) for g in grid]

    def grid_so2(
        self, N: int, type: str = "regular", seed: int = None
    ) -> List[GroupElement]:
        r"""
        .. todo::
            Add documentation

        """

        if type == "regular":
            so2_grid = [i * 2 * np.pi / N for i in range(N)]
        elif type == "rand":
            if isinstance(seed, int):
                rng = np.random.RandomState(seed)
            elif seed is None:
                rng = np.random
            else:
                assert isinstance(seed, np.random.RandomState)
                rng = seed
            so2_grid = [rng.random() * 2 * np.pi for i in range(N)]
        else:
            raise ValueError(f"Grid type {type} not recognized")

        return [self.element((0, g)) for g in so2_grid]

    def testing_elements(self, n=4 * 13) -> Iterable[GroupElement]:
        r"""
        A finite number of group elements to use for testing.
        """
        return iter(
            [self.element((0, i * 2.0 * np.pi / n)) for i in range(n)]
            + [self.element((1, i * 2.0 * np.pi / n)) for i in range(n)]
        )

    def __eq__(self, other):
        if not isinstance(other, O2):
            return False
        else:
            return self.name == other.name

    def _subgroup(
        self, id: Tuple[float, int]
    ) -> Tuple[
        Group,
        Callable[[GroupElement], GroupElement],
        Callable[[GroupElement], GroupElement],
    ]:
        r"""
        Restrict the current group :math:`O(2)` to the subgroup identified by the input ``id``, where ``id`` is a
        tuple :math:`(\theta, M)`.

        Args:
            id (tuple): the identification of the subgroup

        Returns:
            a tuple containing

                - the subgroup

                - a function which maps an element of the subgroup to its inclusion in the original group and

                - a function which maps an element of the original group to the corresponding element in the subgroup (returns None if the element is not contained in the subgroup)

        """
        assert isinstance(id, tuple) and len(id) == 2, id
        assert id[0] is None or isinstance(id[0], float), id[0]
        assert isinstance(id[1], int), id[1]

        axis = id[0]
        order = id[1]

        assert axis is None or 0 <= axis <= 2 * np.pi, (axis, order)
        assert order == -1 or order > 0, (axis, order)

        if id[0] is not None and id[1] == -1:
            sg = O2(self._maximum_frequency)
            parent_mapping = build_adjoint_map(self, self.element((0, axis / 2)))
            child_mapping = build_adjoint_map(self, self.element((0, -axis / 2)))

        elif id[0] is None and id[1] == -1:
            sg = SO2(self._maximum_frequency)
            parent_mapping = partial(so2_to_o2, self)
            child_mapping = partial(o2_to_so2, sg)

        elif id[0] is not None and id[1] == 1:
            # take the elements of the group generated by "2pi/k f"
            sg = CyclicGroup(2)
            parent_mapping = partial(flip_to_o2, axis, self)
            child_mapping = partial(o2_to_flip, axis, sg)

        elif id[0] is None:
            # take the elements of the group generated by "2pi/order"
            sg = CyclicGroup(order)
            parent_mapping = partial(so2_to_o2, self)
            child_mapping = partial(o2_to_so2, sg)

        elif id[0] is not None and id[1] > 1:
            # take the elements of the group generated by "2pi/order" and "2pi/k f"
            sg = DihedralGroup(order)
            parent_mapping = partial(dn_to_o2, axis, self)
            child_mapping = partial(o2_to_dn, axis, sg)
        else:
            raise ValueError(f"id '{id}' not recognized")

        return sg, parent_mapping, child_mapping

    def _combine_subgroups(self, sg_id1, sg_id2):
        sg_id1 = self._process_subgroup_id(sg_id1)
        sg1, inclusion, _ = self.subgroup(sg_id1)
        sg_id2 = sg1._process_subgroup_id(sg_id2)

        if sg_id1[0] is None:
            return (None, sg_id2)
        elif sg_id1[1] == 1:
            return sg_id1[0] if sg_id2 == 2 else None, 1
        elif sg_id2[0] is None:
            return sg_id2
        else:
            flip = sg_id1[0] + (
                inclusion(sg1.element((0, sg_id2[0] * np.pi))).value[1]
                * (2 * np.pi)
                / sg1.rotation_order
            )
            return (flip,) + sg_id2[1:]

    def _build_representations(self):
        r"""
        Build the irreps for this group

        """
        # Build all the irreducible representations and add trivial representation
        j, k = 0, 0
        self.irrep(j, k)

        j = 1
        for k in range(self._maximum_frequency + 1):
            self.irrep(j, k)

        # Build all representations and add all irreps to already build representations
        self.representations.update(**{irr.name: irr for irr in self.irreps()})

    @property
    def trivial_representation(self) -> group_theory.Representation:
        return self.representations["irrep_0,0"]

    def standard_representation(self) -> group_theory.Representation:
        r"""
        Standard representation of :math:`\O2` as 2x2 rotation matrices

        This is equivalent to ``self.irrep(1, 1)``.

        """
        return self.irrep(1, 1)

    def irrep(self, j: int, k: int) -> group_theory.IrreducibleRepresentation:
        r"""
        Build the irrep with reflection and rotation frequencies :math:`j` (reflection) and :math:`k` (rotation) of the
        current
        Notice: the frequencies has to be non-negative integers: :math:`j \in \{0, 1\}` and :math:`k \in \mathbb{N}`

        Valid parameters are :math:`(0, 0)` and :math:`(1, 0)`, :math:`(1, 1)`, :math:`(1, 2)`, :math:`(1, 3)`, ...

        Args:
            j (int): the frequency of the reflection in the irrep
            k (int): the frequency of the rotations in the irrep

        Returns:
            the corresponding irrep

        """

        assert j in [0, 1]
        assert k >= 0

        name = f"irrep_{j},{k}"
        id = (j, k)

        if id not in self._irreps:
            irrep = partial(_build_irrep_o2, j, k)
            character = partial(_build_char_o2, j, k)

            if j == 0:
                if k == 0:
                    # Trivial representation
                    supported_nonlinearities = ["pointwise", "norm", "gated", "gate"]
                    self._irreps[id] = group_theory.IrreducibleRepresentation(
                        self,
                        id,
                        name,
                        irrep,
                        1,
                        "R",
                        supported_nonlinearities=supported_nonlinearities,
                        character=character,
                        frequency=k,
                        flip_frequency=j,
                    )
                else:
                    raise ValueError(
                        f"Error! Flip frequency {j} and rotational frequency {k} don't correspond to any irrep of the group {self.name}!"
                    )

            elif k == 0:
                # add Trivial on SO(2) subgroup Representation
                supported_nonlinearities = ["norm", "gated"]
                self._irreps[id] = group_theory.IrreducibleRepresentation(
                    self,
                    id,
                    name,
                    irrep,
                    1,
                    "R",
                    supported_nonlinearities=supported_nonlinearities,
                    character=character,
                    frequency=k,
                    flip_frequency=j,
                )
            else:
                # 2 dimensional Irreducible Representations
                supported_nonlinearities = ["norm", "gated"]
                self._irreps[id] = group_theory.IrreducibleRepresentation(
                    self,
                    id,
                    name,
                    irrep,
                    2,
                    "R",
                    supported_nonlinearities=supported_nonlinearities,
                    character=character,
                    frequency=k,
                    flip_frequency=j,
                )

        return self._irreps[id]

    def _induced_from_irrep(
        self,
        subgroup_id: Tuple[float, int],
        repr: group_theory.IrreducibleRepresentation,
        representatives: List[GroupElement] = None,
    ) -> Tuple[List[group_theory.IrreducibleRepresentation], np.ndarray, np.ndarray]:
        if representatives is None:
            if subgroup_id == (None, -1):
                # SO(2) has finite index in O(2)
                # so we can build the set of representatives explicitly
                representatives = [self.identity, self.reflection]
            else:
                raise ValueError(
                    f"Induction from discrete subgroups of O(2) leads to infinite dimensional induced "
                    f"representations. Hence, induction from the subgroup identified "
                    f"by {subgroup_id} is not allowed."
                )

        return super(O2, self)._induced_from_irrep(subgroup_id, repr, representatives)


def _build_irrep_o2(j: int, k: int, element: GroupElement) -> np.ndarray:
    assert j in [0, 1]
    assert k >= 0

    if j == 0:
        if k == 0:
            # Trivial representation
            return np.eye(1)
        else:
            raise ValueError(
                f"Error! Flip frequency {j} and rotational frequency {k} don't correspond to any irrep of the group {element.name}!"
            )
    elif k == 0:
        # Trivial on SO(2) subgroup group_theory.Representation
        return np.array([[-1 if element.value[0] else 1]])
    else:
        e = element.value
        # 2 dimensional Irreducible group_theory.Representations
        return psichi(e[1], e[0], k=k)


def _build_char_o2(j: int, k: int, element: GroupElement) -> float:
    assert j in [0, 1]
    assert k >= 0

    if j == 0:
        if k == 0:
            # Trivial representation
            return 1.0
        else:
            raise ValueError(
                f"Error! Flip frequency {j} and rotational frequency {k} don't correspond to any irrep of the group {element.name}!"
            )
    elif k == 0:
        # add Trivial on SO(2) subgroup group_theory.Representation
        return -1 if element[0] else 1
    else:
        e = element.value
        # 2 dimensional Irreducible group_theory.Representations
        return 0 if e[0] else (2 * np.cos(k * e[1]))


# SO2 (and Cyclic) ###############################
def o2_to_so2(so2: Union[SO2, CyclicGroup], e: GroupElement):
    assert isinstance(e.group, O2)

    flip, rotation = e.value

    if flip == 0:
        try:
            return so2.element(rotation)
        except ValueError:
            return None
    else:
        return None


def so2_to_o2(o2: O2, e: GroupElement):
    assert isinstance(e.group, SO2) or isinstance(e.group, CyclicGroup)
    return o2.element((0, e.value))


# Flip wrt an axis ######################################
def o2_to_flip(axis: float, flip: CyclicGroup, e: GroupElement):
    assert isinstance(flip, CyclicGroup) and flip.rotation_order == 2
    assert isinstance(e.group, O2)

    f, rot = e.value

    if f == 0 and cycle_isclose(rot, 0, 2 * np.pi):
        return flip.identity
    elif f == 1 and cycle_isclose(rot, axis, 2 * np.pi):
        return flip.element(1)
    else:
        return None


def flip_to_o2(axis: float, o2: O2, e: GroupElement):
    assert isinstance(e.group, CyclicGroup) and e.group.rotation_order == 2

    f = e.value

    if f == 0:
        return o2.identity
    else:
        return o2.element((1, axis))


# Dihedral Group ######################################
def o2_to_dn(axis: float, dn: DihedralGroup, e: GroupElement):
    assert isinstance(dn, DihedralGroup)
    assert isinstance(e.group, O2)

    f, rot = e.value

    if cycle_isclose(rot - f * axis, 0.0, 2.0 * np.pi / dn.rotation_order):
        return dn.element(
            (
                f,
                int(round((rot - f * axis) * dn.rotation_order / (2.0 * np.pi))),
            )
        )
    else:
        return None


def dn_to_o2(axis: float, o2: O2, e: GroupElement):
    assert isinstance(e.group, DihedralGroup)

    f, rot = e.value

    return o2.element((f, rot * 2.0 * np.pi / e.group.rotation_order + f * axis))
