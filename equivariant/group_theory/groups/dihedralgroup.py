from __future__ import annotations

from .group import Group, GroupElement
from .cyclicgroup import CyclicGroup

from equivariant import group_theory
from equivariant.group_theory.utils import psichi

import numpy as np
from functools import partial

from typing import Tuple, Callable, Iterable, List

__all__ = ["DihedralGroup"]


class DihedralGroup(Group):
    def __init__(self, N: int):
        r"""
        Build an instance of the dihedral group :math:`D_N` which contains reflections and ``N`` discrete planar
        rotations.
        The order of the group :math:`D_N` is :math:`2N`.

        The group elements are
        :math:`\{e,\, r,\, r^2,\, r^3,\, \dots,\, r^{N-1},\, f,\, rf,\, r^2f,\, r^3f,\, \dots,\, r^{N-1}f\}`,
        so an element of this group is either a rotation :math:`r^k` or a reflection :math:`r^kf` along an axis.

        Any group element is either a discrete rotation :math:`r^k` by an angle :math:`k\frac{2\pi}{N}` or a
        reflection :math:`f` followed by a rotation, i.e. :math:`r^kf`.
        As in :class:`~CyclicGroup`, combination of rotations behaves like arithmetic modulo ``N``, so
        :math:`r^a \cdot r^b = r^{\ a + b \!\! \mod \!\! N}\ `.
        Two reflections gives the identity :math:`f \cdot f = e` and a reflection commutes with a rotation by inverting
        it, i.e. :math:`r^k \cdot f = f \cdot r^{-k}`.

        A group element :math:`r^kf^j` is implemented as a pair :math:`(j, k)` with :math:`j \in \{0, 1\}` and
        and :math:`k \in \{0, \dots, N-1\}`.



        Subgroup Structure.

        A subgroup of :math:`D_{2N}` is identified by a tuple ``id`` :math:`(k, M)`.

        Here, :math:`M` is a positive integer indicating the number of discrete rotations in the subgroup while
        :math:`k` is either ``None`` or an integer in :math:`\{0, \dots, \frac{N}{M}-1\}`. If :math:`k` is ``None``,
        the subgroup does not contain any reflections. Otherwise, the subgroup contains the reflection :math:`r^k f`
        along the axis of the current group rotated by :math:`k\frac{\pi}{N}`.
        The order :math:`M` has to divide the rotation order :math:`N` of the current group (:math:`D_{2N}`).

        Valid combinations are:

        - (``None``, :math:`M`): restrict to the cyclic subgroup :math:`C_M` generated by :math:`\langle r^{N/M} \rangle`.

        - (:math:`k`, :math:`M`): restrict to the dihedral subgroup :math:`D_{M}` generated by :math:`\langle r^{N/M}, r^{k}f \rangle`

        In particular:

        - (``None``, :math:`1`): restrict to the cyclic subgroup of order 1 containing only the identity

        - (:math:`0`, :math:`1`): restrict to the reflection group generated by :math:`\langle f \rangle`

        - (:math:`0`, :math:`M`): restrict to the dihedral subgroup :math:`D_{M}` generated by :math:`\langle r^{N/M}, f \rangle`

        - (:math:`k`, :math:`1`): restrict to the reflection group generated by :math:`\langle r^{k}f \rangle = \{e, r^{k}f\}`


        Args:
            N (int): number of discrete rotations in the group

        Attributes:

            ~.reflection: the reflection element
            ~.rotation_order (int): the number of discrete rotations in this group (equal to the parameter ``N``)

        """

        assert isinstance(N, int) and N > 0, N

        super(DihedralGroup, self).__init__("D%d" % N, False, False)

        self.rotation_order = N
        self._elements = [self.element((0, i * (2 * np.pi) / N)) for i in range(N)] + [
            self.element((1, i * (2 * np.pi) / N)) for i in range(N)
        ]

        self._identity = self.element((0, 0.0))
        self.reflection = self.element((1, 0.0))

        self._build_representations()

    @property
    def generators(self) -> List[GroupElement]:
        if self.rotation_order > 1:
            return [self.element((0, 1)), self.element((1, 0))]
        else:
            return [self.element((1, 0))]

    @property
    def subgroup_trivial_id(self):
        return (None, 1)

    @property
    def subgroup_self_id(self):
        return (0.0, self.rotation_order)

    ###########################################################################
    # METHODS DEFINING THE GROUP LAW AND THE OPERATIONS ON THE GROUP'S ELEMENTS
    ###########################################################################

    def sample(self) -> GroupElement:
        return self.element(
            (
                np.random.randint(0, 2),
                np.random.randint(0, self.rotation_order)
                * (2 * np.pi)
                / self.rotation_order,
            )
        )

    def testing_elements(self) -> Iterable[GroupElement]:
        r"""
        A finite number of group elements to use for testing.
        """
        return iter(self._elements)

    def __eq__(self, other):
        if not isinstance(other, DihedralGroup):
            return False
        else:
            return (
                self.name == other.name and self.rotation_order == other.rotation_order
            )

    def _subgroup(
        self, id: Tuple[int, int]
    ) -> Tuple[
        Group,
        Callable[[GroupElement], GroupElement],
        Callable[[GroupElement], GroupElement],
    ]:
        r"""
        Restrict the current group :math:`D_{2N}` to the subgroup identified by the input ``id``, where ``id`` is a
        tuple :math:`(k, M)`.

        Args:
            id (tuple): the identification of the subgroup

        Returns:
            a tuple containing

                - the subgroup,
                - a function which maps an element of the subgroup to its inclusion in the original group and
                - a function which maps an element of the original group to the corresponding element in the
                  subgroup (returns None if the element is not contained in the subgroup)

        """

        assert isinstance(id, tuple) and len(id) == 2
        assert id[0] is None or isinstance(id[0], int)
        assert isinstance(id[1], int)
        assert id[1] >= 1

        axis = id[0]
        order = id[1]

        assert self.rotation_order % order == 0, (
            "Error! The rotations order of the subgroups of a dihedral group has to divide the rotations order of the over"
            " %d does not divide %d " % (order, self.rotation_order)
        )

        assert axis is None or 0 <= axis < self.rotation_order

        if id[0] is not None and id[1] == 1:
            # take the elements of the group generated by "r^axis f"
            sg = CyclicGroup(2)
            parent_mapping = partial(flip_to_dn, axis, self)
            child_mapping = partial(dn_to_flip, axis, sg)

        elif id[0] is None:
            # take the elements of the group generated by "r^ratio"
            sg = CyclicGroup(order)
            parent_mapping = partial(cn_to_dn, self)
            child_mapping = partial(dn_to_cn, sg)

        else:
            # take the elements of the group generated by "r^ratio" and "r^axis f"
            sg = DihedralGroup(order)
            parent_mapping = partial(dm_to_dn, axis, self)
            child_mapping = partial(dn_to_dm, axis, sg)

        return sg, parent_mapping, child_mapping

    def _combine_subgroups(self, sg_id1, sg_id2):
        sg_id1 = self._process_subgroup_id(sg_id1)
        sg1, inclusion, _ = self.subgroup(sg_id1)
        sg_id2 = sg1._process_subgroup_id(sg_id2)

        if sg_id1[0] is None:
            return (None, sg_id2)
        elif sg_id1[1] == 1:
            return sg_id1[0] if sg_id2 == 2 else None, 1
        elif sg_id2[0] is None:
            return sg_id2
        else:
            flip = sg_id1[0] + inclusion(sg1.element((0, sg_id2[0])))[1]
            return (flip,) + sg_id2[1:]

    def _build_representations(self):
        r"""
        Build the irreps and the regular representation for this group

        """

        n = self.rotation_order

        # Build all the irreducible representations
        # add Trivial representation
        j, k = 0, 0
        self.irrep(j, k)

        j = 1

        for k in range(0, int(n // 2) + 1):
            self.irrep(j, k)

        if n % 2 == 0:
            j = 0
            self.irrep(j, k)

        # Build all representations
        # add all the irreps to the set of representations already built for this group
        self.representations.update(**{irr.name: irr for irr in self.irreps()})

        # build the regular representation
        # N.B.: it represents the LEFT-ACTION of the elements
        self.representations["regular"] = self.regular_representation

    @property
    def trivial_representation(self) -> group_theory.Representation:
        return self.irrep(0, 0)

    def irrep(self, j: int, k: int) -> group_theory.IrreducibleRepresentation:
        r"""
        Build the irrep with reflecion and rotation frequencies :math:`j` (reflection) and :math:`k` (rotation) of the
        current dihedral  Note: the frequencies has to be non-negative integers, i.e.
        :math:`j \in [0, 1]` and :math:`k \in \{0, \dots, \left\lfloor N/2 \right\rfloor \}`,
        where :math:`N` is the rotational order of the group (the number of rotations, i.e. the half the group order).

        If :math:`N` is odd, valid parameters are :math:`(0, 0)`, :math:`(1, 0)`, :math:`(1, 1)` ... :math:`(1, \left\lfloor N/2 \right\rfloor)`.
        If :math:`N` is even, the group also has the irrep :math:`(0, N/2)`.

        Args:
            j (int): the frequency of the reflections in the irrep
            k (int): the frequency of the rotations in the irrep

        Returns:
            the corresponding irrep

        """

        N = self.rotation_order
        id = (j, k)

        assert j in [0, 1]
        assert 0 <= k <= N // 2

        name = f"irrep_{j},{k}"

        if id not in self._irreps:
            irrep = partial(_build_irrep_dn, j, k)
            character = partial(_build_char_dn, j, k)

            if j == 0:
                if k == 0:
                    # Trivial representation
                    supported_nonlinearities = [
                        "pointwise",
                        "norm",
                        "gated",
                        "gate",
                        "concatenated",
                    ]
                    self._irreps[id] = group_theory.IrreducibleRepresentation(
                        self,
                        id,
                        name,
                        irrep,
                        1,
                        "R",
                        supported_nonlinearities=supported_nonlinearities,
                        character=character,
                        frequency=k,
                        flip_frequency=j,
                    )

                elif N % 2 == 0 and k == N // 2:
                    supported_nonlinearities = ["norm", "gated", "concatenated"]
                    self._irreps[id] = group_theory.IrreducibleRepresentation(
                        self,
                        id,
                        name,
                        irrep,
                        1,
                        "R",
                        supported_nonlinearities=supported_nonlinearities,
                        character=character,
                        frequency=k,
                        flip_frequency=j,
                    )
                else:
                    raise ValueError(
                        f"Error! Flip frequency {j} and rotational frequency {k} don't correspond to any irrep of the group {self.name}!"
                    )

            else:
                if k == 0:
                    # Trivial on Cyclic subgroup group_theory.Representation
                    supported_nonlinearities = ["norm", "gated", "concatenated"]
                    self._irreps[id] = group_theory.IrreducibleRepresentation(
                        self,
                        id,
                        name,
                        irrep,
                        1,
                        "R",
                        supported_nonlinearities=supported_nonlinearities,
                        character=character,
                        frequency=k,
                        flip_frequency=j,
                    )

                elif N % 2 == 0 and k == N / 2:
                    # 1 dimensional Irreducible representation (only for groups with an even number of rotations)
                    supported_nonlinearities = ["norm", "gated", "concatenated"]
                    self._irreps[id] = group_theory.IrreducibleRepresentation(
                        self,
                        id,
                        name,
                        irrep,
                        1,
                        "R",
                        supported_nonlinearities=supported_nonlinearities,
                        character=character,
                        frequency=k,
                        flip_frequency=j,
                    )
                else:
                    # 2 dimensional Irreducible group_theory.Representations
                    supported_nonlinearities = ["norm", "gated"]
                    self._irreps[id] = group_theory.IrreducibleRepresentation(
                        self,
                        id,
                        name,
                        irrep,
                        2,
                        "R",
                        supported_nonlinearities=supported_nonlinearities,
                        character=character,
                        frequency=k,
                        flip_frequency=j,
                    )

        return self._irreps[id]


def _build_irrep_dn(j: int, k: int, element: GroupElement) -> np.ndarray:
    N = element.group.rotation_order

    if j == 0:
        if k == 0:
            return np.eye(1)
        elif N % 2 == 0 and k == N // 2:
            return np.array([[np.cos(k * element.value[1])]])
        else:
            raise ValueError(
                f"Error! Flip frequency {j} and rotational frequency {k} don't correspond to any irrep of the group {element.name}!"
            )
    else:
        if k == 0:
            # Trivial on Cyclic subgroup group_theory.Representation
            return np.array([[-1 if element.value[0] else 1]])
        elif N % 2 == 0 and k == N / 2:
            e = element.value
            # 1 dimensional Irreducible representation (only for groups with an even number of rotations)
            return np.array([[np.cos(k * e[1]) * (-1 if e[0] else 1)]])
        else:
            # 2 dimensional Irreducible group_theory.Representations
            e = element.value
            return psichi(e[1], e[0], k=k)


def _build_char_dn(j: int, k: int, element: GroupElement) -> float:
    N = element.group.rotation_order

    if j == 0:
        if k == 0:
            return 1.0
        elif N % 2 == 0 and k == N // 2:
            return np.cos(k * element.value[1])
        else:
            raise ValueError(
                f"Error! Flip frequency {j} and rotational frequency {k} don't correspond to any irrep of the group {element.name}!"
            )
    else:
        if k == 0:
            # Trivial on Cyclic subgroup group_theory.Representation
            return -1 if element.value[0] else 1
        elif N % 2 == 0 and k == N / 2:
            e = element.value
            # 1 dimensional Irreducible representation (only for groups with an even number of rotations)
            return np.cos(k * e[1]) * (-1 if e[0] else 1)
        else:
            # 2 dimensional Irreducible group_theory.Representations
            e = element.value
            return 0 if e[0] else (2 * np.cos(k * e[1]))


# Cyclic ###############################
def dn_to_cn(cn: CyclicGroup, e: GroupElement):
    assert isinstance(e.group, DihedralGroup)

    flip, rotation = e.value

    ratio = e.group.rotation_order // cn.order()

    if flip == 0 and rotation % ratio == 0:
        return cn.element(rotation // ratio)
    else:
        return None


def cn_to_dn(dn: DihedralGroup, e: GroupElement):
    assert isinstance(e.group, CyclicGroup)

    ratio = dn.rotation_order // e.group.order()

    return dn.element((0, e.value * ratio))


# Flip wrt an axis ######################################
def dn_to_flip(axis: int, flip: CyclicGroup, e: GroupElement):
    assert isinstance(flip, CyclicGroup) and flip.order() == 2
    assert isinstance(e.group, DihedralGroup)

    f, rot = e.value

    if f == 0 and rot == 0:
        return flip.identity
    elif f == 1 and rot == axis:
        return flip.element(1)
    else:
        return None


def flip_to_dn(axis: int, dn: DihedralGroup, e: GroupElement):
    assert isinstance(e.group, CyclicGroup) and e.group.order() == 2

    f = e

    if f == 0:
        return dn.identity
    else:
        return dn.element(1, axis)


# Dihedral Group ######################################
def dn_to_dm(axis: int, dm: DihedralGroup, e: GroupElement):
    assert isinstance(dm, DihedralGroup)
    assert isinstance(e.group, DihedralGroup)

    f, rot = e.value

    ratio = e.group.rotation_order // dm.rotation_order
    if (rot - f * axis) % ratio != 0:
        return None
    else:
        return dm.element((f, (rot - f * axis) // ratio))


def dm_to_dn(axis: int, dn: DihedralGroup, e: GroupElement):
    assert isinstance(e.group, DihedralGroup)

    f, rot = e.value

    ratio = dn.rotation_order // e.group.rotation_order

    return dn.element((f, rot * ratio + f * axis))
